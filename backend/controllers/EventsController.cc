/**
 *
 *  EventsController.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "EventsController.h"
#include "Models.h"
#include "plugins/JWTService.h"
#include "plugins/StateUpdateScheduler.h"
#include "utils/Macros.h"
#include <drogon/HttpResponse.h>
#include <drogon/HttpTypes.h>
#include <json/value.h>
#include <string>

void EventsController::getOne(
    const HttpRequestPtr& req,
    std::function<void(const HttpResponsePtr&)>&& callback,
    Events::PrimaryKeyType&& id)
{
    EventsControllerBase::getOne(req, std::move(callback), std::move(id));
}

void EventsController::updateOne(
    const HttpRequestPtr& req,
    std::function<void(const HttpResponsePtr&)>&& callback,
    Events::PrimaryKeyType&& id)
{
    EventsControllerBase::updateOne(req, std::move(callback), std::move(id));
}

void EventsController::deleteOne(
    const HttpRequestPtr& req,
    std::function<void(const HttpResponsePtr&)>&& callback,
    Events::PrimaryKeyType&& id)
{
    auto dbClient{ drogon::app().getDbClient() };
    Mapper<Event> mapper{ dbClient };
    auto callbackPtr{ MAKE_CALLBACK_HEAP_PTR(callback) };
    auto currentUserId{ CURRENT_USER_ID(req) };

    mapper.findByPrimaryKey(
        id,
        [currentUserId, id, callbackPtr, req, this](Event eventToDelete) mutable // id gets const qual and cannot be binded to rval
        {
            if (eventToDelete.getValueOfAuthorId() == currentUserId)
            {
                drogon::app()
                    .getPlugin<augventure::plugins::StateUpdateScheduler>()
                    ->removeTaskByKey(id);

                EventsControllerBase::deleteOne(req, std::move(*callbackPtr),
                                                std::move(id));
            }
            else
            {
                Json::Value ret;
                ret["error"] = "not owner";
                auto response{ HttpResponse::newHttpJsonResponse(ret) };
                response->setStatusCode(drogon::k403Forbidden);
                (*callbackPtr)(response);
            }
        },
        [=](const DrogonDbException& e)
        {
            LOG_TRACE << e.base().what();
            auto resp{ HttpResponse::newHttpResponse(k400BadRequest,
                                                     CT_TEXT_PLAIN) };
            resp->setBody("database exception: " +
                          (std::string)e.base().what());
            (*callbackPtr)(resp);
        });
}

void EventsController::get(
    const HttpRequestPtr& req,
    std::function<void(const HttpResponsePtr&)>&& callback)
{
    EventsControllerBase::get(req, std::move(callback));
}

void EventsController::create(
    const HttpRequestPtr& req,
    std::function<void(const HttpResponsePtr&)>&& callback)
{
    auto json{ req->jsonObject() };
    auto callbackPtr{ MAKE_CALLBACK_HEAP_PTR(callback) };
    if (json)
    {
        (*json)[Events::Cols::_author_id] = CURRENT_USER_ID(req);
    }
    EventsControllerBase::create(
        req,
        [callbackPtr](const HttpResponsePtr& resp)
        {
            if (resp->statusCode() == drogon::k200OK)
            {
                using namespace augventure::plugins;
                auto eventJson{ *resp->jsonObject() };
                drogon::app().getPlugin<StateUpdateScheduler>()->schedule(
                    StateUpdateScheduler::TaskType::EventStart,
                    dateFromJsonString(eventJson["start"].asString()),
                    eventJson["id"].as<PrimaryKeyType>());
            }
            (*callbackPtr)(resp);
        });
}
